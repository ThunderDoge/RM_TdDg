**!!!不论如何实现串口,以下用例必须通过才能交付!!!**

# 发送测试样例帧

* 云台相对角度控制

  函数调用:gimbal_relative_control(1.2,3.4,1,2);

​       底层发送:ff 13 9a 99 99 3f 9a 99 59 40 1 2 0 0 0 0 f9 d

# 接收测试样例

* 使用云台角度控制作为测试样例

**1.正常接收**

底层接收:ff 13 9a 99 99 3f 9a 99 59 40 1 98 0 0 0 0 8f d

解包结果:1.2 3.4 1 152

有时候会出现缓冲区数据不足,继续等待接收即可

**2.两帧数据之间有乱码**

底层接收:

{0xff ,0x13 ,0x9a ,0x99 ,0x99 ,0x3f ,0x9a ,0x99 ,0x59 ,0x40

​     ,0x1 ,0xfa ,0x0 ,0x0 ,0x0 ,0x0 ,0xf1 ,0xd}

{0x13, 0x9a ,0x99,0x99, 0x3f}(短垃圾测试) / 长垃圾测试该序列*3

{0xff ,0x13 ,0x9a ,0x99 ,0x99 ,0x3f ,0x9a ,0x99 ,0x59 ,0x40

​     ,0x1 ,0xfb ,0x0 ,0x0 ,0x0 ,0x0 ,0xf2 ,0xd }

解包结果:1.2 3.4 1 250      1.2 3.4 1 251(长短垃圾测试结果相同)

**3.前置垃圾信息,先发第一帧前半帧,后发第一帧后半帧数,再发后续一完整帧**

底层接收:

{0x13, 0x9a ,0x99,0x99, 0x3f}

{0xff ,0x13 ,0x9a ,0x99 ,0x99 ,0x3f ,0x9a ,0x99 ,0x59 ,0x40

​    ,0x1 ,0xfa ,0x0}

延时等待1000ms

{0x0 ,0x0 ,0x0 ,0xf1 ,0xd}

{0xff ,0x13 ,0x9a ,0x99 ,0x99 ,0x3f ,0x9a ,0x99 ,0x59 ,0x40

​     ,0x1 ,0xfb ,0x0 ,0x0 ,0x0 ,0x0 ,0xf2 ,0xd }

解包结果:1.2 3.4 1 250      1.2 3.4 1 251

**4.缓冲区前2.5为垃圾信息,有半帧有效信息,继续发送完正常帧**

底层接收:

{0x54 ,0x13 ,0x9a ,0x99 ,0x99 ,0x3f ,0x9a ,0x99 ,0x59 ,0x40

​     ,0x1 ,0xfa ,0x20 ,0xa0 ,0x0 ,0x0 ,0x41 ,0x6d}

{0x54 ,0x13 ,0x9a ,0x99 ,0x99 ,0x3f ,0x9a ,0x99 ,0x59 ,0x40

​     ,0x1 ,0xfa ,0x20 ,0xa0 ,0x0 ,0x0 ,0x41 ,0x6d}

{0xff ,0x13 ,0x9a ,0x99 ,0x99 ,0x3f ,0x9a ,0x99 ,0x59 ,0x40

​    ,0x1 ,0xfa ,0x0};

延时等待1000ms

{0x0 ,0x0 ,0x0 ,0xf1 ,0xd};

解包结果:1.2 3.4 1 250

**5.首尾符合条件,校验和失败,无效首尾之间有有效数据的前半帧数**

底层接收:

{0xff ,0x13 ,0x9a ,0x99 ,0x99 ,0x3f ,0x9a ,0x99 ,0x59 ,0x40

​     ,0x1 ,0xfa ,0x0 ,/*重合段起始*/ 0xff ,0x13 ,0x0 ,0xf1 ,0xd,/*重合段终止*/

​     0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0xa,0xb,/*校验和*/0x5f,0xd}

解包结果:2.60705e-38 6.20716e-36 6 7

# 测试结论

测试样例全部通过